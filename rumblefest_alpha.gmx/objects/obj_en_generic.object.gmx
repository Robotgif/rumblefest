<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>600</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize generic enemy

// List of states
enum states {
    WALKING_IN,
    CLIMBING_IN,
    ROAMING,
    BEING_HIT,
    VULNERABLE,
    ELIMINATED
}

enum directions {
    UP = 90,
    DOWN = 270,
    LEFT = 180,
    RIGHT = 0
}

// Thresholds for hitting ropes
topBound = 420

// Prefix for sprites
spritePrefix = "spr_en"

// "Active" refers to in the ring and able to interact with user
isActive = false;

// Need a flag instead of a state to avoid race conditions
isEliminated = false;

// Another flag for collisions
collisionFlag = false;

// When player hits enemy, keep track of direction of collision. -1 is default or unset.
playerCollisionDir = -1

// Initialize variables to set direction going down
// (from above ring), then climb into ring and proceed with normal behavior

// TODO: Move this into state management in step event if multiple image speeds are necessary
image_speed = .1
state = states.WALKING_IN;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set state back to roaming after being hit
/// Use alarm 11 to not interfere with others

collisionFlag = false;
state = states.ROAMING;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle variables based on state

switch (state) {
case states.WALKING_IN:
    direction = directions.DOWN;
    image_speed = .1;
    speed = 4;
    depth = 600;
    sprite_index = asset_get_index(spritePrefix + "_down");
    break;
case states.CLIMBING_IN:
    speed = 0;
    image_speed = .1;
    depth = 600;
    sprite_index = asset_get_index(spritePrefix + "_entrance");
    // Change depth just on last frame
    // Steps are fractions, so need to check upper/lower bounds
    if ( image_index &gt;= 7 &amp;&amp; image_index &lt; 8) {
        depth = -500
    }
    break;
case states.ROAMING:
    speed = 4;
    image_speed = .1;
    mask_index = spr_mask_en_vulnerable;
    // Separate directional sprites
    switch(direction) {
        case directions.UP:
            sprite_index = asset_get_index(spritePrefix + "_up");
            mask_index = spr_mask_en_up;
            break;
        case directions.DOWN:
            sprite_index = asset_get_index(spritePrefix + "_down");
            mask_index = spr_mask_en_down;
            break;
        case directions.LEFT:
            sprite_index = asset_get_index(spritePrefix + "_left");
            mask_index = spr_mask_en_left;
            break;
        case directions.RIGHT:
            sprite_index = asset_get_index(spritePrefix + "_right");
            mask_index = spr_mask_en_right;
            break;
    }
    break;
case states.VULNERABLE:
    speed = 0;
    image_speed = .1;
    sprite_index = asset_get_index(spritePrefix + "_vulnerable");
    mask_index = spr_mask_en_vulnerable;
    break;
case states.BEING_HIT:
    if (instance_exists(obj_player)) {
        image_speed = .2;
        direction = obj_player.direction;
        mask_index = spr_mask_en_vulnerable;
        if (direction == directions.DOWN) {
            sprite_index = asset_get_index(spritePrefix + "_being_hit_d");
        } else {
            sprite_index = asset_get_index(spritePrefix + "_being_hit");
        }
    }
    break; 
case states.ELIMINATED:
    // Separate directional sprites
    speed = 4;
    image_speed = .1;
    switch(direction) {
        case directions.UP:
            sprite_index = asset_get_index(spritePrefix + "_back_out");
            break;
        case directions.DOWN:
            sprite_index = asset_get_index(spritePrefix + "_front_out");
            break;
        case directions.RIGHT:
            image_xscale = -1;
            // Note that break is omitted intentionally
        case directions.LEFT:
            sprite_index = asset_get_index(spritePrefix + "_l_out");
            break;
    }
    // Need to set flag here instead of state because we can have a race condition where
    // the punching sprite ends when state is set to ELIMINATED, so the animation
    // end event will fire and not actually show the eliminated sprite
    isEliminated = true;
    break; 
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collisions with player when vulnerable

if ((state == states.VULNERABLE || state == states.BEING_HIT) &amp;&amp; instance_exists(obj_player)) {

    playerDirection = obj_player.direction;
    playerSpeed = obj_player.speed;
    
    if (playerDirection == 0 &amp;&amp; place_meeting(x - playerSpeed, y, obj_player)) {
            x = x + playerSpeed;
            state = states.BEING_HIT;
            collisionFlag = true;
            
    } else if (playerDirection == 90 &amp;&amp; place_meeting(x, y + playerSpeed, obj_player)) {

            y = y - playerSpeed;
            state = states.BEING_HIT;
            collisionFlag = true;

    } else if (playerDirection == 180 &amp;&amp; place_meeting(x + playerSpeed, y, obj_player)) {

            x = x - playerSpeed;
            state = states.BEING_HIT;
            collisionFlag = true;

    } else if (playerDirection == 270 &amp;&amp; place_meeting(x, y - playerSpeed, obj_player)) {

            y = y + playerSpeed;
            state = states.BEING_HIT;
            collisionFlag = true;

    } else {
        if (collisionFlag) {
            state = states.VULNERABLE;
            alarm[1] = room_speed * 3;
            // TODO: Make sure this doesn't fuck with anything else
            collisionFlag = false
        }
    }

}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collisions with wall
// Normal state when roaming
if (state == states.ROAMING &amp;&amp; place_meeting(x, y, obj_wall_en)) {

    // "Momentum" will take enemy into the colliding object,
    // so push away from ropes (using 400x400 as a general center of the ring)
    // TODO: Could be improved based on incoming position
    while (!place_free(x, y)) {
        if (y &lt; 400) {
            y = y + speed;
        } else {
            y = y - speed;
        }
        
        if (x &lt; 400) {
            x = x + speed;
        } else {
            x = x - speed;
        }
        
    }
    // Call event to change direction
    event_user(1)

    
} else if (state == states.BEING_HIT) {

    // Get x and y deltas from directions
    switch (direction) {
    case directions.UP:
        xd = 0
        yd = 0 + speed;
        break;
    case directions.DOWN:
        xd = 0
        yd = 0 + speed;
        break;
    case directions.LEFT:
        xd = 0 - speed
        yd = 0;
        break;
    case directions.RIGHT:
        xd = 0 + speed;
        yd = 0;
        break;
    }
    
        // Check if colliding, only proceed if yes
    shouldContinue = true
    if (!place_meeting(x + xd, y + yd, obj_wall_en)) {
        shouldContinue = false;
    }
    
    // Debug, prob won't work for all enemies
    // Just checking x/y coords that happen when we collide with ropes as opposed
    // to checking actual collision directions which were wonky
    
    // Outer if because "return()" was fucking up
    if (shouldContinue) {
    
        if (x &lt;= 136) {
            expectedDirection = directions.LEFT;
            moveDirection = "left";
        } else if (x &gt;= 632) {
            expectedDirection = directions.RIGHT;
            moveDirection = "right";
        } else if (y &lt;= 390) {
            expectedDirection = directions.UP;
            moveDirection = "back";
        } else {
            expectedDirection = directions.DOWN;
            moveDirection = "front";
        }
        
        
        // Only change to eliminated if direction matches actual direction
        if (direction == expectedDirection) {
            wiggly_ropes(moveDirection)
            enemy_eliminated();
            state = states.ELIMINATED
        }
    
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collisions with player when roaming

if (state == states.ROAMING &amp;&amp; place_meeting(x, y, obj_player)) {   
    
    // Move back player
    with (obj_player) {
        if (!flashing) {
            collisionDirection = point_direction(x,y, other.x, other.y)
            event_user(0)
        }
    }

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change depth based on position relative to player
// Don't run this if we're entering
if (state == states.WALKING_IN || 
    state == states.CLIMBING_IN ) {
    
    

} else if (state == states.ELIMINATED) {
    depth = -2001;
} else {
    // Player has the same code, so depth is relative to y position
    depth = -500 - y;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_entrance_wall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change to climbing animation when hitting ropes

if (!isActive) {
    state = states.CLIMBING_IN;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Alarm to set state to vunerable (tired)
state = states.VULNERABLE

// After 3 seconds go back to normal if we're not being punched
alarm[1] = room_speed * 3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change direction
newDirection = direction;

while (newDirection == direction) {
    newDirection = choose(directions.UP, directions.DOWN, directions.LEFT, directions.RIGHT);
  
}

direction = newDirection;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// First time entering ring
state = states.ROAMING;

// For now keep going down, could call this to change direction if we wanted
//event_user(1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// If animation ends in climbing up mode, switch to roaming state
if (state == states.CLIMBING_IN) {
    state = states.ROAMING;
    isActive = true
    
    // Run event to set up roaming
    event_user(0)
}

// If animation ends when eliminated, just remove self
// Need to use variable instead of state to avoid race condition
if (isEliminated) {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
