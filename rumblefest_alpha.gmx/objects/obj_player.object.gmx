<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_still</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-500</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>speed = 0
image_speed = 0

// Bring in same state variables as enemy
// Right now we're only using GHOST and MOVING
MOVING = 0
IS_HURT = 1
TIRED = 2
PUNCHING_PLAYER = 3
WAKE_UP = 4
ELIMINATED = 5
ENTERING = 6
GHOST = 7
KNOCKED_BACK = 8
STILL = 9

// TODO: Refactor this to use all enums
enum player_states {
    MOVING,
    IS_HURT,
    TIRED,
    PUNCHING_PLAYER,
    WAKE_UP,
    ELIMINATED,
    ENTERING,
    GHOST,
    KNOCKED_BACK,
    STILL
}

// Set initial state to MOVING
state = STILL

// When hit, set flashing to true which makes player invincible for short time
flashing = false

// This just makes sure random numbers are different every game
randomize();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set player to not flashing after a certain amount of time

flashing = false
image_alpha = 1

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (obj_heart_cont.hasHearts) {
    state = MOVING
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Alarm for moving player back after being hit
// moveBackAmount will decrease as this is called to slide the player back


moveDirection = 0;
// collisionDirection is rounded, so find closest arrow direction to move in
if (collisionDirection &gt; 45 &amp;&amp; collisionDirection &lt; 135) {
    moveDirection = 90;
} else if (collisionDirection &gt;= 135 &amp;&amp; collisionDirection &lt; 225) {
    moveDirection = 180;
} else if (collisionDirection &gt;= 225 &amp;&amp; collisionDirection &lt; 305) {
    moveDirection = 270;
} else {
    moveDirection = 0;
}

if (moveBackAmount &gt; 0) {
    
    // Turn off normal player speed while getting knocked back
    speed = 0;
    
    // Move player depending on which way they are facing
    if (moveDirection == 0) {
        x = x - 7
    }
    if (moveDirection == 90) {
        y = y + 7
    }
    if (moveDirection == 180) {
        x = x + 7
    }
    if (moveDirection == 270) {
        y = y - 7
    }
    

    // Set character sprite to being hurt
    state = KNOCKED_BACK
    
    // Decrease our move back amount so we know when to stop (when it gets to 0)
    moveBackAmount = moveBackAmount - 1
    
    // Set collision index so we can go through enemies
    
    
    // Call this alarm again
    alarm[0] = 1
} else {
    // When moveBackAmount is at 0, set speed to normal if we still have hearts
    if (obj_heart_cont.hasHearts) {
        // Set character sprite to being hurt
        state = STILL
    } else {
        state = TIRED
    }
    
    // Set state back to moving after an amount of time
    // Note that we've turned this off for now so it fires right away
    alarm[1] = 1
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check states
// Flashing animation 
if (flashing) {
    flashingCount++
    
    if (flashingCount mod 2 == 0) {
        image_alpha = .8
    } else {
        image_alpha = .3
    }
    
}

// Override sprite indices set previously if we're being knocked back
shouldContinue = true;
if (state == KNOCKED_BACK) {
    sprite_index = spr_punched;
    shouldContinue = false;
}

if (shouldContinue) {

if (state == STILL) {
    sprite_index = spr_still
    speed = 0
}

// Change direction when hitting keyboard buttons
if (global.lastKeyPressed == "down"){
    direction = 270
    if (state == STILL) {
        state = MOVING
    }
}
if (global.lastKeyPressed == "up"){
    direction = 90
    if (state == STILL) {
        state = MOVING
    }
}
if (global.lastKeyPressed == "left"){
    direction = 180
    if (state == STILL) {
        state = MOVING
    }
}
if (global.lastKeyPressed == "right"){
    direction = 0
    if (state == STILL) {
        state = MOVING
    }
}

if (state == TIRED) {
    speed = 2
    if (direction == 0) {
        sprite_index = spr_tired_right;
    } else if (direction == 90) {
        sprite_index = spr_tired_up;
    } else if (direction == 180) {
        sprite_index = spr_tired_left;
    } else {
        sprite_index = spr_tired_down;
    }
    
    mask_index = spr_mask_player_vulnerable;
}

// Change sprite based on direction when moving
if (state == MOVING) {
    speed = 4
    image_speed = .2
    
    if (direction == 0) {
        sprite_index = spr_right;
        mask_index = spr_mask_player_right;
    } else if (direction == 90) {
        sprite_index = spr_up;
        mask_index = spr_mask_player_up;
    } else if (direction == 180) {
        sprite_index = spr_left;
        mask_index = spr_mask_player_left;
    } else {
        sprite_index = spr_down;
        mask_index = spr_mask_player_down;
    }
}

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change depth based on y value

depth = -500 - y;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall_player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != MOVING &amp;&amp; state != PUNCHING_PLAYER &amp;&amp; state != TIRED) {
    // collisionDirection is rounded, so find closest arrow direction to move in
    // need to go in opposite direction than coming from
    if (collisionDirection &gt; 45 &amp;&amp; collisionDirection &lt; 135) {
        // coming from direction = 90;
        direction = 270
    } else if (collisionDirection &gt;= 135 &amp;&amp; collisionDirection &lt; 225) {
        // coming from direction = 180;
        direction = 0
    } else if (collisionDirection &gt;= 225 &amp;&amp; collisionDirection &lt; 305) {
        // coming from direction = 270;
        direction = 90
    } else {
        // coming from direction = 0;
        direction = 180
    }
    instance_change(obj_player_eliminated, true);
} else if (state == MOVING || state == TIRED) {
    // bounce off ropes
    if (direction == 0) {
        global.lastKeyPressed = "left"
        wiggly_ropes("right")
    } else if (direction == 90) {
        global.lastKeyPressed = "down"
        wiggly_ropes("back")
    } else if (direction == 180) {
        global.lastKeyPressed = "right"
        wiggly_ropes("left")
    } else if (direction == 270) {
        global.lastKeyPressed = "up"
        wiggly_ropes("front")
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Event triggered by collecting a heart, set state back to moving instead of tired

if (state == TIRED) {
    state = MOVING;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Event when colliding with normal roaming enemy

// Get knocked back based on which direction we're facing
// moveBackAmount is how many times we will call alarm[0] to push the player back
moveBackAmount = 18

alarm[0] = 1

// Set to flashing, then set alarm to make un-flashing
flashing = true
// Used to flip flashing
flashingCount = 0


alarm[2] = 1.5 * room_speed

// Lose a heart
with (obj_heart_cont) {
    event_user(0)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/*
TODO: Add camera flash?
if (false) {
    draw_set_blend_mode(bm_add); //(or try experimenting with draw_set_blend_mode_ext)
    draw_self(); //(or draw_sprite or whatever)
    draw_set_blend_mode(bm_normal);
} else {
    draw_self();
}
*/

draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>-1</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
