<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_still</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-500</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set initial variables for player

speed = 0
image_speed = 0

// DEBUG 

/*
collisionDirection = 0
event_user(0)
event_user(0)
event_user(0)
*/

// Bring in same state variables as enemy
// Right now we're only using GHOST and MOVING
MOVING = 0
IS_HURT = 1
TIRED = 2
PUNCHING_PLAYER = 3
WAKE_UP = 4
ELIMINATED = 5
ENTERING = 6
GHOST = 7
KNOCKED_BACK = 8
STILL = 9
GETTING_BACK_IN = 10
TIRED_PUNCHING = 11

// TODO: Refactor this to use all enums
enum player_states {
    MOVING,
    IS_HURT,
    TIRED,
    PUNCHING_PLAYER,
    WAKE_UP,
    ELIMINATED,
    ENTERING,
    GHOST,
    KNOCKED_BACK,
    STILL
}

enum player_weapons {
    NONE,
    CHAIR
}

// Set initial to no weapon
weapon = player_weapons.NONE;

// Set initial state to MOVING
state = STILL

// When hit, set flashing to true which makes player invincible for short time
flashing = false

// This just makes sure random numbers are different every game
randomize();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Screen shake 

view_object[0] = noone;

randX = random_range(-10, 10)
randY = random_range(-10, 10)

view_xview[0] = 0 + randX
view_yview[0] = 0 + randY

shakeAmount--
if (shakeAmount &gt; 0) {
    alarm[11] = room_speed * 0.05
} else {
    view_xview[0] = 0
    view_yview[0] = 0
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set player to not flashing after a certain amount of time

flashing = false
image_alpha = 1

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set to moving if we have hearts
if (obj_heart_cont.hasHearts) {
    state = MOVING
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Alarm for moving player back after being hit
// moveBackAmount will decrease as this is called to slide the player back

// Don't do anything if we're getting back in 
if (state != GETTING_BACK_IN) {


moveDirection = 0;
// collisionDirection is rounded, so find closest arrow direction to move in
if (collisionDirection &gt; 45 &amp;&amp; collisionDirection &lt; 135) {
    moveDirection = 90;
} else if (collisionDirection &gt;= 135 &amp;&amp; collisionDirection &lt; 225) {
    moveDirection = 180;
} else if (collisionDirection &gt;= 225 &amp;&amp; collisionDirection &lt; 305) {
    moveDirection = 270;
} else {
    moveDirection = 0;
}

if (moveBackAmount &gt; 0) {
    
    // Turn off normal player speed while getting knocked back
    speed = 0;
    
    // Move player depending on which way they are facing
    if (moveDirection == 0) {
        x = x - 7
    }
    if (moveDirection == 90) {
        y = y + 7
    }
    if (moveDirection == 180) {
        x = x + 7
    }
    if (moveDirection == 270) {
        y = y - 7
    }
    

    // Set character sprite to being hurt
    state = KNOCKED_BACK
    
    // Decrease our move back amount so we know when to stop (when it gets to 0)
    moveBackAmount = moveBackAmount - 1
    
    // Set collision index so we can go through enemies
    
    
    // Call this alarm again
    alarm[0] = 1
} else {
    // When moveBackAmount is at 0, set speed to normal if we still have hearts
    if (obj_heart_cont.hasHearts) {
        // Set character sprite to being hurt
        state = STILL
    } else {
        state = TIRED
    }
    
    // Set state back to moving after an amount of time
    // Note that we've turned this off for now so it fires right away
    alarm[1] = 1
}

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check states

// Reset image x_scale if we changed it previously 
image_xscale = 1;

// Flashing animation 
if (flashing) {
    flashingCount++
    
    if (flashingCount mod 2 == 0) {
        image_alpha = .8
    } else {
        image_alpha = .3
    }
    
}

// Override sprite indices set previously if we're being knocked back
shouldContinue = true;
if (state == KNOCKED_BACK) {
    sprite_index = spr_punched;
    shouldContinue = false;
}

if (state == GETTING_BACK_IN) {
    speed = 0;
    if (direction == 0) {
        image_xscale = -1;
        sprite_index = spr_hld_sides;
    } else if (direction == 90) {
        sprite_index = spr_hld_front;
    } else if (direction == 180) {
        sprite_index = spr_hld_sides;
    } else {
        sprite_index = spr_hld_back
    }
    shouldContinue = false;
}

if (shouldContinue) {

if (state == STILL) {
    sprite_index = spr_still
    speed = 0
}

// Change direction when hitting keyboard buttons
if (global.lastKeyPressed == "down"){
    direction = 270
    if (state == STILL) {
        state = MOVING
    }
}
if (global.lastKeyPressed == "up"){
    direction = 90
    if (state == STILL) {
        state = MOVING
    }
}
if (global.lastKeyPressed == "left"){
    direction = 180
    if (state == STILL) {
        state = MOVING
    }
}
if (global.lastKeyPressed == "right"){
    direction = 0
    if (state == STILL) {
        state = MOVING
    }
}

// Change sprite based on direction when moving
if (state == MOVING || state == TIRED || state == TIRED_PUNCHING) {
    speed = 4
    image_speed = .2
    
    spriteToSet = "spr"
    
    // Override sprite prefix speed if tired, then override again if weilding weapon
    if (state == TIRED) {
        spriteToSet = "spr_tired"
        mask_index = spr_mask_player_vulnerable;
        speed = 2
    }
    if (state == TIRED_PUNCHING) {
        show_debug_message("tired...")
        spriteToSet = "spr_tired_punching"
        mask_index = spr_mask_player_vulnerable;
        speed = 2
    }
    
    show_debug_message(state)
    
    if (weapon == player_weapons.CHAIR) {
        spriteToSet = "spr_player_chair"
        speed = 4;
    }
    
    // Set masks for normal player movement, or override with weapon if applicable
    if (direction == 0) {
        spriteToSet += "_right"
        mask_index = spr_mask_player_right;
        
        if (weapon == player_weapons.CHAIR) {
            if (image_index % 2 == 0) {
                mask_index = spr_chair_mask_right_01;  
            } else {
                mask_index = spr_chair_mask_right_02; 
            }
        }
        
        
    } else if (direction == 90) {
        spriteToSet += "_up"
        mask_index = spr_mask_player_up;
        if (weapon == player_weapons.CHAIR) {
            if (image_index % 2 == 0) {
                mask_index = spr_chair_mask_up_01;  
            } else {
                mask_index = spr_chair_mask_up_02; 
            }
        }
    } else if (direction == 180) {
        spriteToSet += "_left"
        mask_index = spr_mask_player_left;
        if (weapon == player_weapons.CHAIR) {
            if (image_index % 2 == 0) {
                mask_index = spr_chair_mask_left_01;  
            } else {
                mask_index = spr_chair_mask_left_02; 
            }
        }
    } else {
        spriteToSet += "_down"
        mask_index = spr_mask_player_down;
        if (weapon == player_weapons.CHAIR) {
            if (image_index % 2 == 0) {
                mask_index = spr_chair_mask_down_01;  
            } else {
                mask_index = spr_chair_mask_down_02; 
            }
        }
    }
    
    sprite_index = asset_get_index(spriteToSet);
}

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change depth based on y value

depth = -500 - y;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check to see if we are colliding with wall 
/// Collisions with wall
// Set mask to normal (override chair masks)
    
// Set masks for normal player movement, or override with weapon if applicable
currentMaskIndex = mask_index;
xModifier = 0;
yModifier = 0;

if (direction == 0) {
    mask_index = spr_mask_player_right;
    xModifier = speed;
} else if (direction == 90) {
    mask_index = spr_mask_player_up;
    yModifier = 0 - speed;
} else if (direction == 180) {
    mask_index = spr_mask_player_left;
    xModifier = 0 - speed;
} else {
    mask_index = spr_mask_player_down;
    yModifier = speed;
}


if (state == TIRED) {
    mask_index = spr_mask_player_vulnerable
}

if (place_meeting(x + xModifier, y + yModifier, obj_wall_player)) {

    if (state == KNOCKED_BACK) {
        // Trigger eliminated / get back in animation
        event_user(4)
    } else if (state == MOVING || state == TIRED) {
    // bounce off ropes
    if (direction == 0) {
        global.lastKeyPressed = "left"
        wiggly_ropes("right")
    } else if (direction == 90) {
        global.lastKeyPressed = "down"
        wiggly_ropes("back")
    } else if (direction == 180) {
        global.lastKeyPressed = "right"
        wiggly_ropes("left")
    } else if (direction == 270) {
        global.lastKeyPressed = "up"
        wiggly_ropes("front")
    }
    
    // Throw chair if currently equipped
    if (weapon == player_weapons.CHAIR) {
        event_user(3)
    }

    }
}

// Set mask index back to whatever it was
mask_index = currentMaskIndex



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Called from enemy object when being punched to indicate they are currently engaged


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Come back into ring if we have hearts, otherwise get fked
if (state != MOVING &amp;&amp; state != PUNCHING_PLAYER &amp;&amp; state != TIRED) {

    if (collisionDirection &gt; 45 &amp;&amp; collisionDirection &lt; 135) {
        // coming from direction = 90;
        direction = 270
    } else if (collisionDirection &gt;= 135 &amp;&amp; collisionDirection &lt; 225) {
        // coming from direction = 180;
        direction = 0
    } else if (collisionDirection &gt;= 225 &amp;&amp; collisionDirection &lt; 305) {
        // coming from direction = 270;
        direction = 90
    } else {
        // coming from direction = 0;
        direction = 180
    }

    if (!obj_heart_cont.hasHearts ) {
        // No hearts, get eliminated
        // collisionDirection is rounded, so find closest arrow direction to move in
        // need to go in opposite direction than coming from
        
        instance_change(obj_player_eliminated, true);
    } else {
        // Otherwise, get back in dat shit!
        image_index = 0;
        state = GETTING_BACK_IN;
    }
        
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Throw dat chair
weapon = player_weapons.NONE;

var chairDirection;
if (direction == directions.UP) {
    chair = instance_create(x, y - 85, obj_chair);
    chairDirection = directions.UP;
} else if (direction == directions.RIGHT) {
    chair = instance_create(x + 75, y, obj_chair);
    chairDirection = directions.RIGHT;
} else if (direction == directions.DOWN) {
    chair = instance_create(x, y + 85, obj_chair);
    chairDirection = directions.DOWN;
} else {
    chair = instance_create(x - 75, y, obj_chair);
    chairDirection = directions.LEFT;
}

with (chair) {
    direction = chairDirection
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pick up chair
weapon = player_weapons.CHAIR;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Event triggered by collecting a heart, set state back to moving instead of tired

if (state == TIRED) {
    state = MOVING;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Event when colliding with normal roaming enemy

// Get knocked back based on which direction we're facing
// moveBackAmount is how many times we will call alarm[0] to push the player back
moveBackAmount = 18

alarm[0] = 1

// Set to flashing, then set alarm to make un-flashing
flashing = true
// Used to flip flashing
flashingCount = 0

// Screen shake
shakeAmount = 10
alarm[11] = 1


alarm[2] = 1.5 * room_speed

// Lose a heart
with (obj_heart_cont) {
    event_user(0)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// After getting back in animation, go back to moving
if (state == GETTING_BACK_IN) {
    state = MOVING;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/*
TODO: Add camera flash?
if (false) {
    draw_set_blend_mode(bm_add); //(or try experimenting with draw_set_blend_mode_ext)
    draw_self(); //(or draw_sprite or whatever)
    draw_set_blend_mode(bm_normal);
} else {
    draw_self();
}
*/

draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>-1</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
