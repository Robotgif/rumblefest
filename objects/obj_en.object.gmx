<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_en</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-500</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_en_tired</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initial Variables
sprite_index = spr_en
randomize()


MOVING = 0
IS_HURT = 1
TIRED = 2
PUNCHING_PLAYER = 3
WAKE_UP = 4
ELIMINATED = 5
ENTERING = 6
GHOST = 7
KNOCKED_BACK = 8
image_speed = .1

state = MOVING
// if he's colliding with someone, he goes ghost
if (!place_free(x,y)){
    solid = false
    other.state = GHOST
}


isGettingPunched = false;

speed = 4;

direction = 270;

changeDirection();

alarm[0] = room_speed * 1 ///int alarm to 3 seconds

/*
tired alarm
///Tired alarm

if (!isGettingPunched) {

    if (state == MOVING) {
        state = TIRED;
        ///this triggers the alarm again randomly between 1 and 2 seconds
        alarm[0] = room_speed * round (random_range (1,2))
    } else if (state == TIRED) {
        state = MOVING;
        newDirection = direction  //line 3-7 makes sure enemy never moves in same direction 
        while (newDirection == direction){
            randomNum = round(random_range (0,3))
            newDirection = randomNum * 90;
        }
        direction = newDirection;
        show_debug_message(newDirection);
        ///this triggers the alarm again randomly between 10 and 15 seconds
        alarm[0] = room_speed * round (random_range (1,2))
    }
}

isGettingPunched = false;

moving alarm
///moving alarm
direction = round (random_range (0,3)) * 90;

// moving state between 
alarm[1] = room_speed * round (random_range (10,15))


step
if (state == TIRED) {
    speed = 0;
    sprite_index = spr_en_tired
    image_speed = .1
} else {
    speed = 4;
    if (direction == 0) {
        sprite_index = spr_en_right
    }
    if (direction == 90) {
        sprite_index = spr_en_up
    }
    if (direction == 180) {
        sprite_index = spr_en_left
    }
    if (direction == 270) {
        sprite_index = spr_en_down
    }
}


wall


newDirection = direction  //line 3-7 makes sure enemy never moves in same direction 
while (newDirection == direction){
    randomNum = round(random_range (0,3))
    newDirection = randomNum * 90;
}

direction = newDirection;


player 
//Collision with player

if state == TIRED {
    if place_meeting (x+4,y,obj_player){x-=4} //left     
    if place_meeting (x-4,y,obj_player){x+=4} //right  
    if place_meeting (x,y+4,obj_player){y-=4} //up
    if place_meeting (x,y-4,obj_player){y+=4} //down
    sprite_index = spr_en_damage
    image_speed = .2;
    isGettingPunched = true;
}
else {
    isGettingPunched = false;
}




*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Timer to set state to TIRED
if (state != IS_HURT &amp;&amp; state != PUNCHING_PLAYER) {
    state = TIRED;
    changeDirection();
}

// Randomly get time until state changes to moving 
randomNum = round(random_range (3,5)) * room_speed;
alarm[0] = randomNum;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != GHOST || place_free(x,y)){
    /// Timer to set state to MOVING
    solid = true
    if (state != IS_HURT) {
        state = MOVING;
    }
    // Randomly get time until state changes to tired 
    randomNum = round(random_range (6,8)) * room_speed;
    alarm[1] = randomNum;
} else {
    alarm[0] = room_speed * 1 /// try to de-GHOST in 3 seconds
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (place_meeting(x, y, obj_player)) {
    isColliding = true
} else {
    isColliding = false
}


// Perform functions for collisions 
if (isColliding &amp;&amp; !obj_player.flashing) {

    if (state == TIRED || state == IS_HURT) {
    
        // Move enemy based on player direction  
        
        speedToMove = 4
        if (obj_player.state = TIRED) {
            speedToMove = 2
        }
        
        if obj_player.direction == 180 {x-=speedToMove} //left     
        if obj_player.direction == 0   {x+=speedToMove} //right  
        if obj_player.direction == 90  {y-=speedToMove} //up
        if obj_player.direction == 270 {y+=speedToMove} //down
    
        //object_collide(obj_player, self, obj_player.direction)
        state = IS_HURT;
        direction = obj_player.direction
        
            
    } else {
        // If we collide when not tired, trigger hurt animation in player and lose a life
        with (obj_player) {
            collisionDirection = point_direction(x,y, other.x, other.y)
            event_user(0)
        }
        
        with (obj_heart_cont) {
            event_user(0)
        }
    }
    
}


// If he's colliding, we'll set state to IS_HURT
// We want to set it back to moving the moment we stop colliding (but not after)
if (!isColliding &amp;&amp; state == IS_HURT) {
    // Randomly get time to set state back to MOVING
    state = TIRED;
    alarm[0] = -1;
    alarm[1] = -1;
    randomNum = round(random_range (3,5)) * room_speed;
    alarm[0] = randomNum;
}

// Check sprite on every step
checkSprite();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall_en">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != IS_HURT) {
    // changing direction is cool, but we also need to make sure we
    // pop ya back into the ring first
    changeDirection();
} else {
    speed = 4
    instance_change(obj_en_eliminated, true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>-2</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
