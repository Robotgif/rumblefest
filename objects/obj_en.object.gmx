<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_en</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-500</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_en_tired</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initial Variables
sprite_index = spr_en
randomize()

// Debug stuff
debugParticles = false;

// For setting correct sprites
spritePrefix = "spr_en_"
objPrefix = "obj_en_"

// For spit particle
firstHit = false;


MOVING = 0
IS_HURT = 1
TIRED = 2
PUNCHING_PLAYER = 3
WAKE_UP = 4
ELIMINATED = 5
ENTERING = 6
GHOST = 7
KNOCKED_BACK = 8
image_speed = .1

state = MOVING
// if he's colliding with someone, he goes ghost
if (!place_free(x,y)){
    solid = false
    other.state = GHOST
}


isGettingPunched = false;

speed = 4;

direction = 270;

changeDirection();

alarm[0] = room_speed * 1 ///int alarm to 3 seconds

// Set up particle effects
// Define and name the emitters

particleSystem = part_system_create();

global.Particle1 = part_type_create();
part_system_depth( particleSystem, -1001 );

part_type_shape(global.Particle1,pt_shape_square);            //This defines the particles shape
part_type_size(global.Particle1,0.1,0.1,0,0);                    //This is for the size
part_type_scale(global.Particle1,1,1);                       //This is for scaling
part_type_color1(global.Particle1,c_white);                  //This sets its colour. There are three different codes for this
part_type_alpha2(global.Particle1,1, .6);                        //This is its alpha. There are three different codes for this
part_type_speed(global.Particle1, 4, 6, 0, 0);            //The particles speed
part_type_direction(global.Particle1,1,360,0,0);            //The direction
part_type_orientation(global.Particle1,0,0,0,0,1);           //This changes the rotation of the particle
part_type_blend(global.Particle1,0);                         //This is the blend mode, either additive or normal
part_type_life(global.Particle1,1,15);                       //this is its lifespan in steps
//part_type_gravity(global.Particle1, 0.9, 270);

particleEmitter = part_emitter_create(particleSystem);
part_emitter_region(particleSystem, particleEmitter, x - 5, x + 5, y - 30, y - 35, ps_shape_line, ps_distr_linear);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Burst of spit!
if (state == IS_HURT || debugParticles) {
    part_emitter_burst(particleSystem, particleEmitter, global.Particle1, 30);
    alarm[2] = room_speed * 0.25;   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Timer to set state to TIRED
if (state != IS_HURT &amp;&amp; state != PUNCHING_PLAYER) {
    state = TIRED;
    changeDirection();
}

// Randomly get time until state changes to moving 
randomNum = round(random_range (3,5)) * room_speed;
alarm[0] = randomNum;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != GHOST || place_free(x,y)){
    /// Timer to set state to MOVING
    solid = true
    if (state != IS_HURT) {
        state = MOVING;
    }
    // Randomly get time until state changes to tired 
    randomNum = round(random_range (6,8)) * room_speed;
    alarm[1] = randomNum;
} else {
    alarm[0] = room_speed * 1 /// try to de-GHOST in 3 seconds
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (place_meeting(x, y, obj_player)) {
    isColliding = true
    
    // Set original punching direction so we know if we disengage
    rawCollisionDir = point_direction(x,y, obj_player.x, obj_player.y);
    
    // Actually setting inverse of directions here
    if (rawCollisionDir &gt; 45 &amp;&amp; rawCollisionDir &lt; 135) {
        originalCollisionDirection = 270;
    } else if (rawCollisionDir &gt;= 135 &amp;&amp; rawCollisionDir &lt; 225) {
        originalCollisionDirection = 0;
    } else if (rawCollisionDir &gt;= 225 &amp;&amp; rawCollisionDir &lt; 305) {
        originalCollisionDirection = 90;
    } else {
        originalCollisionDirection = 180;
    }

} else {
    isColliding = false
}



// Perform functions for collisions 
if (isColliding &amp;&amp; !obj_player.flashing) {
        
        // Multiple checks here for pushing.  First check if enemy is tired or hurt.
        // Also, if original collision direction isn't the same as current player direction,
        // that means the player moved direction when pushing, so don't do anything else
    if ((state == TIRED || 
        state == IS_HURT)) {
        
        if (obj_player.direction != originalCollisionDirection) {
            exit;
        }
    
        // Move enemy based on player direction  
        speedToMove = 4
        if (obj_player.state = TIRED) {
            speedToMove = 2
        }
        
        if obj_player.direction == 180 {x-=speedToMove} //left     
        if obj_player.direction == 0   {x+=speedToMove} //right  
        if obj_player.direction == 90  {y-=speedToMove} //up
        if obj_player.direction == 270 {y+=speedToMove} //down
    
        state = IS_HURT;
        direction = obj_player.direction
        
            
    } else {
        // If we collide when not tired, trigger hurt animation in player and lose a life
        with (obj_player) {
            collisionDirection = point_direction(x,y, other.x, other.y)
            event_user(0)
        }
        
        with (obj_heart_cont) {
            event_user(0)
        }
    }
    
}


// If he's colliding, we'll set state to IS_HURT
// We want to set it back to moving the moment we stop colliding (but not after)
if (!isColliding &amp;&amp; state == IS_HURT) {
    // Randomly get time to set state back to MOVING
    state = TIRED;
    alarm[0] = -1;
    alarm[1] = -1;
    randomNum = round(random_range (3,5)) * room_speed;
    alarm[0] = randomNum;
}

// Change depth based on position relative to player
if (instance_exists(obj_player) &amp;&amp; obj_player.y &lt; y) {
    depth = -501
} else {
    depth = -500
}

// Check sprite on every step
checkSprite();

// Particles for getting hit, with alarm to set bursts
part_emitter_region(particleSystem, particleEmitter, x - 5, x + 5, y - 30, y - 35, ps_shape_ellipse, ps_distr_linear);
if ((debugParticles &amp;&amp; alarm[2] &lt; 0 ) || state == IS_HURT &amp;&amp; alarm[2] &lt; 0) {
    show_debug_message("????")
    alarm[2] = 1
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall_en">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != IS_HURT) {
    // changing direction is cool, but we also need to make sure we
    // pop ya back into the ring first
    changeDirection();
} else {
    speed = 4
    instance_change(asset_get_index(objPrefix + "eliminated"), true)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.cameraFlashing) {
    draw_set_blend_mode(bm_add); //(or try experimenting with draw_set_blend_mode_ext)
    draw_self(); //(or draw_sprite or whatever)
    draw_set_blend_mode(bm_normal);
} else {
    draw_self();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>-2</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
